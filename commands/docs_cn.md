# 文档生成命令

为代码生成或更新文档，确保遵循 CLAUDE.md 中的文档最佳实践。

## 使用说明：

1. **确定文档目标：**
   - 如果提供了特定文件，为这些文件编写文档
   - 如果未指定目标，询问用户需要什么文档
   - 检查是否存在需要更新的现有文档，而不是重复

2. **文档类型：**

   **代码文档：**
   - 函数/方法文档字符串
   - 类文档
   - 模块级文档
   - 复杂逻辑的内联注释
   - 类型提示/注解

   **API 文档：**
   - 端点描述
   - 请求/响应格式
   - 认证要求
   - 错误代码和处理

   **用户文档：**
   - README 文件
   - 使用指南
   - 安装说明
   - 配置选项
   - 故障排除指南

3. **文档原则（来自 CLAUDE.md）：**

   **动机优先的写作：**
   - 从问题/痛点开始
   - 先解释为什么，再解释怎么做
   - 描述权衡和设计决策

   **事实检查：**
   - 对照实际代码验证所有参数名称
   - 测试所有示例命令
   - 确认默认值和行为
   - 交叉引用相关文档

   **面向读者：**
   - 按用例场景组织
   - 渐进式展示（基础 → 高级）
   - 实用的、可复制粘贴的示例
   - 清晰的标题便于浏览

   **避免反模式：**
   - ❌ 没有上下文的命令
   - ❌ 没有解释的魔法行为
   - ❌ 过时的示例
   - ❌ 没有具体内容的通用建议

4. **文档格式：**

   **对于函数/方法：**
   ```python
   def function_name(param1: Type1, param2: Type2) -> ReturnType:
       """
       简短的一行描述。

       详细解释这个函数做什么以及为什么存在。
       解释它解决的问题，而不仅仅是它做什么。

       Args:
           param1: 描述包括有效值和约束
           param2: 描述包括用途和默认行为

       Returns:
           返回值及其结构的描述

       Raises:
           ErrorType: 何时以及为什么会发生此错误

       Example:
           >>> result = function_name("value", 42)
           >>> print(result)
           expected_output
       """
   ```

   **对于面向用户的文档：**
   ```markdown
   # 功能名称

   ## 问题
   [描述用户面临的痛点]

   ## 解决方案
   [解释此功能如何解决这些问题]

   ## 使用方法

   ### 基本用法
   [简单、完整的示例]

   ### 高级配置
   [更复杂的场景]

   ## 工作原理
   [解释不明显的机制]

   ## 相关
   - [相关文档的链接]
   ```

5. **质量检查：**
   - [ ] 在解决方案之前解释了问题上下文
   - [ ] 对照代码验证了所有参数名称
   - [ ] 测试了所有示例并可以工作
   - [ ] 解释了非标准模式
   - [ ] 交叉引用了相关文档
   - [ ] 没有通用的"最佳实践"废话

## 文档示例：

### 示例 1：动机优先
```markdown
## 问题
传统的音频处理需要将音频数据写入磁盘，这会：
- 增加延迟（磁盘 I/O 需要 50-100ms）
- 存在磁盘已满时数据丢失的风险
- 使清理和错误处理变得复杂

## 解决方案：BytesIO 流式传输
流式传输模块使用内存缓冲区来：
- 完全消除磁盘 I/O
- 直接流式传输到 API
- 通过上下文管理器自动清理

### 使用方法
\```python
with AudioStream() as stream:
    stream.record(duration=5)
    result = stream.transcribe()
\```
```

### 示例 2：代码文档
```python
def process_audio(data: np.ndarray, sample_rate: int = 44100) -> AudioResult:
    """
    处理原始音频数据以进行转录。

    此函数通过在发送到 API 之前标准化采样率和位深度来解决
    音频格式不一致的问题。它使用 numpy 进行向量化操作而不是
    循环以提高性能（遵循 CLAUDE.md 原则）。

    Args:
        data: 原始音频样本作为 numpy 数组，形状为 (n_samples,)
        sample_rate: 原始采样率（Hz）。默认 44100 匹配大多数
                    USB 麦克风。将重采样到 16000 以供 API 使用。

    Returns:
        包含标准化数据和元数据的 AudioResult

    Raises:
        ValueError: 如果 data 为空或 sample_rate <= 0

    Example:
        >>> audio = np.random.randn(44100)  # 1 秒 @ 44.1kHz
        >>> result = process_audio(audio)
        >>> result.sample_rate
        16000
    """
```

## 重要提示：
- 除非明确要求，否则永远不要创建文档文件
- 始终对照实际代码验证技术细节
- 关注为什么，而不仅仅是做什么
- 在包含示例之前测试所有示例
- 链接到相关文档
- 保持简洁但完整
