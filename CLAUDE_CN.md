# CLAUDE.md - 系统级开发指南

## AI 助手原则

### 专业严谨与准确性
- **回答前仔细思考**: 花时间充分理解问题的上下文和含义
- **只提供专业且严谨的答案**: 每个回答必须技术准确且有充分理由
- **零容忍错误**: 如果不确定，先调查验证而非猜测
- **承认局限性**: 当缺乏足够信息无法给出确定答案时，明确说明
- **验证后再声明**: 测试假设、阅读实际代码、检查文档 - 绝不假设

**关键行为:**
- 对复杂问题使用推理/思考过程后再提供答案
- 验证技术细节时交叉引用多个来源
- 优先选择"我需要先验证 X 再回答"，而非可能错误的即时回答
- 当存在多种解释时，展示所有有效选项及其权衡

## 构建命令
<!-- 替换为你的项目构建和测试命令 -->
- 安装: `[你的安装命令]`
- 运行测试: `[你的测试命令]`
- 构建: `[你的构建命令]`
- 带选项运行: `[配置覆盖示例]`

## 开发哲学

### 快速失败 - 禁止防御性编程
这是研究/开发代码,立即暴露 bug 至关重要。绝不要用后备方案隐藏错误。

❌ 禁止:
```python
if x is None: x = default_value  # 不!
try: ... except: use_fallback   # 不!
value = x if x else fallback     # 不!
if hasattr(obj, 'attr'): ...     # 不! 让 AttributeError 暴露 bug
```

✅ 必须:
```python
if x is None:
    raise RuntimeError("x is None - 这表明初始化有 bug")
# 让代码立即崩溃,在源头暴露问题
```

**防御性编程澄清:**
- ✅ 需要检查外部失败(硬件、文件 I/O、网络)
- ❌ 不要检查自己的依赖是否为 None
- ❌ 不要为自己的逻辑错误添加后备方案
- 如果某个依赖在初始化时是必需的,之后它就不应该为 None

### 像科学家/工程师一样思考
编写优雅、清晰的代码,而非防御性业务逻辑。

❌ 错误 - 防御性思维:
```python
if self.config_option_enabled:
    if self.data.shape[1] > 0:
        result = self.process_data()
        # ... 20 多行分支判断
```

✅ 正确 - 科学/工程思维:
```python
# 使用向量化、掩码和预计算
processed_data[active_mask] = self._process_with_config(data[active_mask])
```

**关键原则:**
1. **掩码 > 分支**: 布尔掩码替代条件逻辑 - 使用数组操作而非 if/else 链
2. **预计算一切**: 运行时应该是纯数学 - 将所有逻辑决策移到初始化
3. **向量化操作**: 以张量/数组思考,而非循环 - 利用 SIMD 和 GPU 并行性
4. **函数指针**: 在初始化时分配函数,而非运行时分支 - 使用分派表和回调

### 必需依赖的快速失败
当组件需要某些东西才能运行时,绝不要在使用前检查它是否存在。

❌ 错误 - 静默失败的防御性检查:
```python
if self.required_component:
    if self.required_data:  # 如果为 None 则静默失败!
        result = self.process(self.required_data)
```

✅ 正确 - 如果缺少必需依赖则快速失败:
```python
# 组件必须存在 - 如果初始化不正确则失败
if self.required_component is None:
    raise RuntimeError("required_component is None - 初始化失败")
result = self.required_component.process(self.required_data)
```

**关键原则:** 如果某些东西是正确运行所必需的,它在初始化后就不应该为 None。不要检查 - 直接使用,如果有 bug 就让它快速失败。

### 问题解决协议 - 关键
AI 绝不能在没有用户明确确认的情况下声称问题已解决,特别是在长时间故障排除任务中。

❌ 错误 - 过早的解决声明:
```
"通过更新配置已修复该问题。"
"这应该能解决问题。"
"bug 现在已解决。"
```

✅ 正确 - 寻求明确确认:
```
"我已实现一个潜在修复。请测试并确认是否解决了问题。"
"更改已完成。您能验证问题是否已修复吗?"
"请运行测试并告诉我问题是否仍然存在。"
```

**关键原则:** 只有用户才能确认问题是否真正解决。AI 提供修复并请求验证,但绝不在没有用户确认的情况下假设成功。

### 调试协议 - 关键
调查问题时:
1. **彻底测试** - 运行实际失败场景,不要只是假设修复有效
2. **端到端检查** - 验证完整工作流,而非仅个别组件
3. **等待用户反馈** - 始终询问用户确认问题是否已解决
4. **记录实际行为** - 报告实际发生的情况,而非应该发生的情况
5. **永不声称成功** - 如果测试显示间歇性结果、崩溃或挂起,报告实际行为
6. **区分部分进展和完全解决** - 组件初始化 ≠ 系统正常工作

### 文档开发协议 - 关键
编写或更新文档时,遵循这些原则以确保面向读者、准确和可维护的内容。

#### 动机优先写作
**始终先解释为什么,再解释如何**:
- **问题背景**: 从用户面临的实际痛点开始
- **解决方案理由**: 解释为什么提议的方法能解决这些问题
- **权衡**: 明确不同方法的优势和局限性

❌ 错误 - 没有上下文的命令:
```markdown
## 功能 X
使用 `--flag` 启用:
```

✅ 正确 - 问题驱动的解释:
```markdown
## 问题
传统方法有这些问题:
- 痛点 1
- 痛点 2

## 解决方案: 功能 X
功能 X 通过以下方式解决此问题...
```

#### 架构解释要求
**解释非标准模式和"魔法"行为**:
- **魔法参数**: 解释特殊值在底层实际做什么
- **集成点**: 引用相关系统及其交互方式
- **实现细节**: 机制如何工作,什么触发行为

#### 事实检查和代码验证
**每个技术细节都必须针对实际实现进行验证**:
- **参数名称**: 针对当前配置文件验证
- **默认值**: 检查实际默认值,而非假设值
- **命令语法**: 测试所有示例命令以确保它们有效
- **文件路径**: 验证文件名和位置

**验证流程**:
1. **阅读实际代码**: 检查实现,不要假设行为
2. **验证配置**: 查看实际配置文件以获取当前参数名称和默认值
3. **测试命令**: 运行示例以确认语法和行为
4. **交叉引用**: 适当链接到相关文档

#### 面向读者的结构
**围绕用户场景组织,而非实现结构**:
- **使用场景**: 围绕不同用户上下文构建
- **渐进披露**: 基本用法优先,高级配置其次
- **实用示例**: 用户可以复制粘贴和修改的真实命令

#### 简洁性与完整性平衡
**简洁但不以牺牲基本上下文为代价**:
- **基本动机**: 始终包括问题背景和解决方案理由
- **足够细节**: 解释非显而易见的设计决策和系统交互
- **描述性流程**: 使用段落解释概念,而非仅列表
- **消除冗余**: 删除不增加实际价值的通用"最佳实践"部分

**简洁性技巧**:
- 使用主动语态和直接语言
- 用清晰标题构建以便扫描
- 提供完整示例而非解释每个选项
- 链接到相关文档而非重复

#### 常见文档反模式须避免
❌ **没有上下文的命令**: 列出命令但不解释底层问题
❌ **没有解释的魔法**: 使用特殊语法但不解释其工作原理
❌ **过时示例**: 包含与当前参数名称不匹配的示例
❌ **实现假设**: 假设读者理解非标准架构模式
❌ **通用建议**: 包含没有可操作细节的"最佳实践"部分
❌ **缺失集成**: 未能引用相关系统和文档

#### 文档质量关卡
提交文档更新前:
1. **代码验证**: 针对当前代码验证每个参数名称、命令和示例
2. **动机检查**: 在呈现解决方案前清楚解释问题背景
3. **架构解释**: 清楚解释任何非标准或"魔法"行为
4. **交叉引用**: 适当链接到相关文档和系统
5. **实用完整性**: 用户仅使用提供的信息即可实现目标

## 代码风格
<!-- 根据你的语言和约定自定义 -->
- 导入: 标准库 → 第三方 → 本地
- 使用结构化日志,而非 print 语句
- 包含关键不变量的断言(例如,张量/数组的形状断言)
- 优先选择清晰、明确的代码,而非巧妙技巧
- 优先选择向量化操作而非循环
- 在适用的地方使用类型提示/注解

### Git 提交消息
- **在编写提交消息前始终运行 `git diff` 并阅读整个差异**
- 提交消息必须准确反映所有更改,而非仅最近的修复
- 包括所有文件更改、配置更新和代码修改
- 如适用,遵循常规提交格式

### 预提交钩子处理
- 如果文件被预提交钩子修改,在重试提交前再次对其运行 `git add`
- 预提交修改应包含在同一提交中,而非单独提交

## 实现指南

### 修改前先研究
在更改任何组件前:
1. **理解现有抽象**: 使用搜索工具查找类似模式
2. **遵循既定模式**: 不要重新发明已存在的东西
3. **检查命名约定**: 与现有代码保持一致
4. **阅读相关测试**: 理解预期行为

### 尊重组件职责
每个组件都有特定目的。不要违反关注点分离:
<!-- 根据你的架构自定义 -->
- **组件 A**: 职责 A
- **组件 B**: 职责 B
- **组件 C**: 职责 C

**关键原则:** 保持职责清晰分离。如果组件需要来自另一个领域的功能,委托给适当的组件。

### 架构原则 - 抽象和多态

#### 禁止在基类中放置特定逻辑
- **绝不要在基类或通用组件中放置任务/类型特定逻辑**
- 基类不应该知道特定实现
- 始终抽象思考 - 如果你发现自己检查特定属性,你就违反了抽象
- 实现修复时,选择适用于所有实现的最通用解决方案
- 示例: 统一处理所有项目,而非检查特定项目类型

#### 禁止特殊情况 - 使用多态
**这是适用于整个代码库的核心架构原则。**

项目通过抽象接口广泛使用多态:
<!-- 根据你的抽象自定义 -->
- **接口/基类 1**: 针对不同用例的不同实现
- **接口/基类 2**: 通过通用接口的可插拔行为

**绝不要在通用类中编写特殊情况逻辑:**
- ❌ 错误: `if isinstance(obj, SpecificType): special_handling()`
- ❌ 错误: `if name == "SpecificCase": different_logic()`
- ❌ 错误: `if self.type == "variant": alternative_path()`
- ✅ 正确: 通过接口方法查询对象的能力
- ✅ 正确: 让每个实现通过重写提供自己的行为

**AI 开发警告:**
作为 AI 助手,你倾向于提出快速解决方法和特殊情况,而非优雅的架构解决方案。在实现任何解决方案前,问自己:
1. 我是否在任何地方添加了 "if type == X" 检查?
2. 我是否在通用代码中硬编码了关于特定实现的知识?
3. 这种行为是否可以通过接口方法暴露?
4. 添加新类型是否需要修改通用代码?

如果任何答案是"是",停止并使用适当的多态重新设计。

**关键原则**: 通用代码绝不应该知道特定实现。它应该只知道接口。这确保添加新类型无需更改现有通用代码。

### 编写最少代码
- 不要创建不必要的实例变量
- 使用现有抽象而非重新实现
- 如果你写的比必要的多,你可能做错了
- 积极删除死代码

### 先验证理解
实现前:
1. 阐明每个组件的职责是什么
2. 确保更改与组件的目的一致
3. 如果不确定,研究现有功能如何使用抽象

## AI 开发工作流

<!-- 可选: 管理复杂项目的结构化工作流 -->

本项目使用结构化开发工作流来管理开发任务。

### 任务组织

**任务分类(按前缀):**
<!-- 根据项目的任务分类自定义 -->
- `meta_*`: 工作流、工具和项目组织
- `refactor_*`: 代码质量改进和架构增强
- `feat_*`: 新功能和 API 增强
- `fix_*`: Bug 修复和问题解决
- `docs_*`: 文档改进
- `perf_*`: 性能优化
- `test_*`: 测试覆盖和质量

**文件结构:**
<!-- 根据项目结构自定义 -->
```
tasks/
├── meta-001-workflow-setup.md
├── refactor-001-architecture.md
├── feat-001-new-feature.md
└── ...
```

### 三阶段开发流程

**阶段 1: 超级思考和上下文收集**
- 仔细阅读任务需求
- 使用顺序思考理解问题背景和范围
- 考虑架构约束(组件边界、初始化模式、既定原则)
- 分析特定领域影响(例如,对于性能/研究任务:物理、算法、系统行为)
- 将简要需求扩展为详细的 PRD/架构文档

**阶段 2: 实现规划**
- 创建详细的逐步实现计划
- 确定将修改哪些组件
- 检查架构原则违规(特殊情况、抽象泄漏、职责违规)
- 使用现有测试命令规划测试方法
- 继续前请求用户明确批准

**阶段 3: 实现和验证**
- 使用 TodoWrite 有条不紊地执行计划以跟踪进度
- 维护组件职责分离
- 遵循单一事实来源原则
- 使用项目测试命令彻底测试
- 请求用户审查和明确确认问题解决
- 更新项目跟踪(例如 ROADMAP.md)完成状态

### 工作流规则

1. **每次一项**: 专注单个任务以确保质量
2. **禁止过早解决声明**: 始终请求用户确认
3. **尊重架构约束**: 遵循既定模式和初始化序列
4. **彻底测试**: 在声称完成前使用现有测试命令
5. **更新跟踪**: 标记任务完成并更新项目跟踪文档

### 质量关卡

- 所有代码必须通过现有测试命令
- 必须尊重组件职责
- 必须维护初始化模式(如适用)
- 禁止防御性编程(快速失败原则)
- 用户必须明确确认问题解决
- Git 提交必须反映所有更改

## 组件架构

<!-- 根据你的架构模式自定义 -->

### 单一事实来源
- 每个状态/配置应该只有一个权威来源
- 其他组件通过 getter/属性访问,绝不复制
- 无需手动同步
- 属性/getter 提供清晰访问而不耦合

**示例:**
```python
class Component:
    @property
    def shared_resource(self):
        """从父级访问(单一事实来源)。"""
        return self.parent.shared_resource
```

### 组件开发指南

创建新组件时,遵循以下标准:

#### 组件结构模式
```python
class MyComponent:
    """
    组件描述和职责。

    此组件提供以下功能:
    - 特定职责 1
    - 特定职责 2
    """

    def __init__(self, parent):
        """使用父引用初始化。"""
        self.parent = parent
        self._initialized = False

    @property
    def shared_dependency(self):
        """从父级访问(单一事实来源)。"""
        return self.parent.shared_dependency

    def initialize(self):
        """初始化组件。"""
        # 设置逻辑
        self._initialized = True
```

#### 属性访问器标准

**✅ 始终对父级访问使用属性装饰器:**
```python
@property
def shared_component(self):
    """从父级访问(单一事实来源)。"""
    return self.parent.shared_component
```

**❌ 绝不存储可能过时的直接引用:**
```python
def __init__(self, parent):
    # 错误 - 创建耦合和过时风险
    self.shared = parent.shared
```

### 复杂度驱动的分离

**关键原则**: 不同复杂度级别需要不同架构方法 - 避免在会损害可维护性的地方强制一致性。

**何时提取组件:**
- 显著复杂度差异(例如,3:1 行数比或更高)
- 复杂的多组件协调/编排
- 从复杂性中出现清晰的单一职责
- 提高可测试性和调试性

**何时不提取:**
- 简单、直接的逻辑(约 50 行以下)
- 没有编排复杂性
- 提取会创建不必要的间接性
- 逻辑与当前位置紧密相关

**示例**: 40 行简单输入处理器可能保持内联,而 120+ 行具有多组件协调的编排模块应提取到自己的组件中。

这可以防止:
- **过度抽象**: 对简单逻辑的不必要间接性
- **抽象不足**: 具有复杂嵌入逻辑的臃肿类

## 关键教训 - 优化和重构

### 优化前始终理解
当被要求优化或重构代码时,首先理解它的作用:
- 阅读完整实现并理解其行为
- 识别所有 API 契约和外部接口
- 映射数据流和依赖关系
- 然后才规划保留确切行为的优化

### 绝不硬编码动态数据
如果系统可以动态发现信息,使用该机制:
- 查询配置系统以获取可用组件
- 使用现有注册表和发现机制
- 避免复制存在于其他地方的知识

### 尊重确切要求
当被要求"在不改变逻辑的情况下优化"时:
- 保留输出的所有方面(结构、格式、含义)
- 仅更改内部实现
- 测试输出保持相同

### 在研究代码中不鼓励向后兼容
研究/开发代码应该快速失败并采用当前最佳实践:
- 不要用遗留支持使代码库膨胀
- 干净的中断优于兼容层
- 专注于维护现代、干净的代码库

### 从现有系统查询真相
- 不要维护组件/功能的单独列表
- 使用系统自己的发现机制
- 单一事实来源原则适用于所有地方

---

*根据项目的具体需求自定义此模板,同时保持核心原则。*
